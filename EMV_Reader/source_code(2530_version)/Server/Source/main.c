/*
* Copyright (c) 2015,Yuanjian
* All rights reserved.
*
* 文件名称：main.c
* 文件标识：
* 摘 要：
*
* 当前版本：0.0
* 作 者：   袁舰
* 完成日期：2015年7月17日
*
* 取代版本：
* 原作者:
* 完成日期：
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/


/***********************************************************************************
* INCLUDES
*/

#include "board.h"
#include "jianPrt.h"
#include "led.h"
#include "myMacros.h"
#include "types.h"
#include "hal_rf.h"
#include "basic_rf.h"
#include <stdio.h>
#include <string.h>
#include "Key.h"
#include "Clock.h"

/***********************************************************************************
* 全局变量
*/
	 TASK_COMPONENTS TaskComps[] = 
		{
#ifdef DATA_HUB
			{0,   0,     0, Rx0Back},			
			{0,   0,     0, Rx1Back},
			{0,   0,	 0, ReceivedFrameDecode},
			{0,   100,	 100, halLedToggle_1},			
#else
			{0,   0,     0, Rx0Back},	
			{0, 1,	 1, checkKey},					
			{0,   0,	 0, ReceivedFrameDecode}, 
			{0,   150,	 150, halLedToggle_1}
#endif
		};
/*********************************************************************************************************
** 函数名称: main
** 功能描述: 主函数，用户程序从这里执行
** 输　入: 无
** 输　出: 无
** 全局变量: 无
** 调用模块: BoardInit(),basicRfInit()
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void main(void)
{
    //prt初始化
    //PrtTimer3_Init();
    //PrtGPIOInit();//Prt   
    // Initalise board peripherals
    BoardInit();

    // 无线模块初始化
    basicRfInit();
	
	while(1)
    {
      TaskProcess();
    }; 
}


/*********************************************************************************************************
** 函数名称: T4_IRQ
** 功能描述: 片选轮询系统的定时器中断
** 输　入: 无
** 输　出: 无
** 全局变量: 无
** 调用模块: TaskRemarks();
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#pragma vector=T4_VECTOR
__interrupt void T4_IRQ(void)
{
	EA = FALSE;
	
	TaskRemarks();
	
	EA = TRUE;
}


/*********************************************参数********************************************************/
extern uint8 *Rx0;    						//接收移动指针
extern uint8 Uart0Rx[];						//接收缓存
uint16 Rx0Count = 0;						//计数
uint8 checkInterval = Interval_9600;		//包间隔时间

/*********************************************************************************************************
** 函数名称: URX0_IRQ
** 功能描述: UART0 中断服务函数
** 输　入: 无
** 输　出: 无
** 全局变量: 无
** 调用模块: 无
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#pragma vector=URX0_VECTOR
__interrupt void URX0_IRQ(void){
	EA = FALSE;
#ifdef DATA_HUB
	*Rx0= U0DBUF;
	Rx0++;
	Rx0Count++;
	//溢出处理
	if(Rx0 == &Uart0Rx[999])
	{
		//清空UART接收缓存 UartRx
		memset(Uart0Rx,0x0,1000);			
		//指针回零
		Rx0= Uart0Rx;
	}
//#error nice
	TaskComps[0].Timer = checkInterval;
#else
#if 0
	*Rx0= U0DBUF;
	if(*Rx0 == 0x08)
	{
		//UART0_SendByte('x');
		UART0_SendByte(*Rx0);
		UART0_SendByte(0x20);
		UART0_SendByte(0x08);
	}
	else if(*Rx0 == 0x7f)
	{
		//UART0_SendByte(*Rx0);
		UART0_SendByte('e');
	}
	else if(*Rx0 == 0x37)
	{
		UART0_SendByte('f');
	}
	else if(*Rx0 == 27)
	{
		UART0_SendByte('g');
	}
	else
	{
		UART0_SendByte(*Rx0);
		//UART0_SendByte('c');
		//printf("%d\r\n",*Rx0);
	}
	Rx0++;
#endif
#if 1
	*Rx0= U0DBUF;
	Rx0++;
	Rx0Count++;
	//溢出处理
	if(Rx0 == &Uart0Rx[999])
	{
		//清空UART接收缓存 UartRx
		memset(Uart0Rx,0x0,1000);			
		//指针回零
		Rx0= Uart0Rx;
	}

	TaskComps[0].Timer = 2;
#endif
//#error get
#endif
	EA = TRUE;
}


/*********************************************参数********************************************************/

uint16 Rx1Count = 0;   		
extern uint8 *Rx1;
extern uint8 Uart1Rx[];

/*********************************************************************************************************
** 函数名称: URX1_IRQ
** 功能描述: UART1 中断服务函数
** 输　入: 无
** 输　出: 无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#pragma vector=URX1_VECTOR
__interrupt void URX1_IRQ(void){
	EA = FALSE;

	*Rx1= U1DBUF;
	Rx1++;
	Rx1Count++;
	
	//清空UART接收缓存 UartRx
	if(Rx1 == &Uart1Rx[999])
	{
		//清空UART接收缓存 UartRx
		memset(Uart0Rx,0x0,1000);			
		//指针回零
		Rx0= Uart0Rx;
	}

	TaskComps[1].Timer = checkInterval;
	
	EA = TRUE;
}


/*********************************************************************************************************
** 函数名称: P1_ISR
** 功能描述: P1 外部中断服务函数
** 输　入: 无
** 输　出: 无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#pragma vector = P1INT_VECTOR  
 __interrupt void P1_ISR(void)  
{  
	static uint8 status  = 0;
	if(P1IFG>0)  
	{  
		if(P1IFG&BIT3)  
  		{  
  	   		if(status == 0)
	  	   {
			PICTL &= ~BIT1;     //上升沿触发
			status = 1;
			MCU_IO_SET_LOW_PREP(0, 5);
			MCU_IO_SET_LOW_PREP(1, 2);
	  	   }
		   else
		   {
			PICTL |= BIT1;     //下降沿触发
			status = 0;
			MCU_IO_SET_HIGH_PREP(0, 5);
			MCU_IO_SET_HIGH_PREP(1, 2);
		   }
  		}  
  		P1IFG = 0;  
	}  
	P1IF = 0;  
}   


