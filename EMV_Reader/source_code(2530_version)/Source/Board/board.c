/*
* Copyright (c) 2015,Yuanjian
* All rights reserved.
*
* 文件名称：board.c
* 文件标识：
* 摘 要：
*
* 当前版本：0.0
* 作 者：   袁舰
* 完成日期：2015年7月17日
*
* 取代版本：
* 原作者:
* 完成日期：
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#include "board.h"
#include "clock.h"
#include "led.h"
#include "jianPrt.h"
#include "Basic_rf.h"
#include "Hal_rf.h"
#include <stdio.h>
#include <string.h>
#include <myMacros.h>
#include <Key.h>
#include "clrc663.h"

#include "data.h"
#include<stdlib.h>

/***********************************************************************************
* GLOBAL VARIABLES
*/


extern TASK_COMPONENTS TaskComps[];

extern uint8 ChannelTable[];

uint8 Uart0Rx[50] = {0};
uint8 Uart0Tx[300] = {0};


uint8 *Rx0 = Uart0Rx;

/******************************************参数**********************************************************/

extern uint16 Rx0Count;
/*********************************************************************************************************
** 函数名称: Rx0Back
** 功能描述: 串口0收到整包数据后触发，指针回到接收缓存的起始位置
** 输　入:	 无
** 输　出:   无
** 全局变量: Rx0Count		该包数据的字符总数
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void Rx0Back(void)
{
	uint16 count;
	count = Rx0Count;
	Rx0Count = 0;

	//指针回零
	Rx0 = Uart0Rx;
	//Uart包解析
	Uart0FrameDecode(count);
}


/******************************************参数**********************************************************/

extern uint8 dataBuffer[11][128];
/*********************************************************************************************************
** 函数名称: Uart0FrameDecode
** 功能描述: 串口0的数据解析，即收到MCU数据的解析，修改
** 输　入:	 count				收到数据数量
** 输　出:   无
** 全局变量: checkInterval		两包数据时间间隔，速率不同间隔也不同
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void Uart0FrameDecode(uint16 count)
{
	if(Uart0Rx[0] == 'A' && Uart0Rx[1] == 'T' && Uart0Rx[2] == '+')
	{
		if(Uart0Rx[3] == 'C')
		{
			if(ReturnConnectStatus() == CONNECTED)
			{
				printf("AT+OK");
				return;
			}
			else
			{
				printf("AT+ERROR");
				return;
			}

		}

		if(Uart0Rx[3] >= '0' && Uart0Rx[3] <= '9')
		{	if(dataBuffer[Uart0Rx[3] - '0'][0] != 0)
			{
				//dataBuffer[Uart0Rx[3] - '0'][0] -= 2;
				UART0_SendData(dataBuffer[Uart0Rx[3] - '0'], dataBuffer[Uart0Rx[3] - '0'][0] + 1);
			}
			else
			{
				printf("AT+NOINFO");
			}
			if(Uart0Rx[3] - '0' == dataBuffer[0][4])
			{
				CleanBuff(dataBuffer);
			}
			//return;
		}
		else if(Uart0Rx[3] == 'A')
		{
			if(dataBuffer[10][0] != 0)
			{
				//dataBuffer[10][0] -= 2 ;
				UART0_SendData(dataBuffer[10], dataBuffer[10][0] + 1);
			}
			else
			{
				printf("AT+NOINFO");
			}
			CleanBuff(dataBuffer);
			//return;
		}
	}

  memset(Uart0Rx,0x0,50);
}


#if 0
void Uart0FrameDecode(uint16 count)
{
  if(Uart0Rx[0] == 'A' && Uart0Rx[1] == 'T')
  {
	if(Uart0Rx[2] == '0')
	{
		if(ReturnConnectStatus() == CONNECTED)
		{
			printf("AT+OK");
		}
		else
		{
			printf("AT+ERROR");
		}

	}

	if( Uart0Rx[2] == '1')
	{
		if(Uart0Rx[3] >= '0' && Uart0Rx[3] <= '9' && Uart0Rx[4] == 0)
		{
			if(dataBuffer[Uart0Rx[3] - '0'][3] != 0 )
			{
				if(dataBuffer[Uart0Rx[3] - '0'][4] & 0x80) //交易记录类数据开头为‘0’
				{
					UART0_SendByte('0');
				}
				else
				{
					UART0_SendByte('1');//其他数据开头为‘1’
				}

				for(uint8 j = 0;j <dataBuffer[Uart0Rx[3] - '0'][0] - 4;j++)
				{
					//printf("%x",dataBuffer[Uart0Rx[3] - '0'][j+5]);
					UART0_SendByte(dataBuffer[Uart0Rx[3] - '0'][j+5]);
				}

				dataBuffer[Uart0Rx[3] - '0'][3] = 0 ;
			}
			else
			{
				printf("ATOVER");
			}


		}

		if(Uart0Rx[3] >= '0' && Uart0Rx[3] <= '2' && Uart0Rx[4] >= '0' && Uart0Rx[4] <= '9'&&Uart0Rx[5] == 0)
		{
			uint8 tmp = (Uart0Rx[3] - '0')*10 + Uart0Rx[4] - '0';
			if(tmp >= 24)
			{
				memset(Uart0Rx,0x0,50);
				return;
			}
			if(dataBuffer[tmp][3] != 0)
			{
				if(dataBuffer[tmp][4] & 0x80) //交易记录类数据开头为‘0’
				{
					UART0_SendByte('0');
				}
				else
				{
					UART0_SendByte('1');//其他数据开头为‘1’
				}

				for(uint8 j = 0;j <dataBuffer[tmp][0] - 4;j++)
				{
					//printf("%x",dataBuffer[Uart0Rx[3] - '0'][j+5]);
					UART0_SendByte(dataBuffer[tmp][j+5]);
				}

				dataBuffer[tmp][3] = 0;
			}
			else
			{
				printf("ATOVER");
			}


		}

#if 0
		if(dataBuffer[Uart0Rx[3] - '0'] != 0 )
		{
			if(Uart0Rx[4] & 0x80) //交易记录类数据开头为‘0’
			{
				UART0_SendByte('0');
			}
			else
			{
				UART0_SendByte('1');//其他数据开头为‘1’
			}

			for(uint8 j = 0;j <dataBuffer[Uart0Rx[3] - '0'][0] - 4;j++)
			{
				//printf("%x",dataBuffer[Uart0Rx[3] - '0'][j+5]);
				UART0_SendByte(dataBuffer[Uart0Rx[3] - '0'][j+5]);
			}
		}
#endif

	}
  }

  memset(Uart0Rx,0x0,50);
}
#endif
#if 0
if(dataBuffer[i][0] != 0)
{
	for(uint8 j = 0;j<=dataBuffer[i][0];j++)
	{
		printf("%x,",dataBuffer[i][j]);
	}
	printf("\r\n");

	dataBuffer[i][0]   = 0;
}
#endif
/*********************************************************************************************************
** 函数名称: CheckInputStr
** 功能描述: 检查用户输入的经纬度格式是否正确
** 输　入:	 *buffer				数组指针
** 输　出:   0						格式错误
**			 1						格式正确
** 全局变量:
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月27日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8 CheckInputStr(uint8 *buffer)
{
	uint8 pointCount = 0;
	if(buffer[0] == '-')
	{
		if(buffer[1] >= '1' && buffer[1] <= '9')
		{
			for(uint8 i = 2;i < 12;i ++)
			{
				if(buffer[i] == '.')
				{
					pointCount++;
					if(i > 4)
					{
						return 0;
					}

					if(buffer[i+8] != 0)
					{
						return 0;
					}
				}

				if(!((buffer[i] >= '0' && buffer[i] <= '9') || buffer[i] == '.' || buffer[i] == 0))
				{
					return 0;
				}

			}
			if(pointCount > 1)
			{
				return 0;
			}
			else if( pointCount == 0)
			{
				if(buffer[4] != 0)
				{
					return 0;
				}
			}
		}
		else
		{
			return 0;
		}

		if(buffer[12] != 0)
		{
			return 0;
		}

		return 1;
	}
	else if (buffer[0] >= '0' && buffer[0] <= '9')
	{
		for(uint8 i = 1;i < 11;i ++)
		{
			if(buffer[i] == '.')
			{
				pointCount++;
				if(i > 3)
				{
					return 0;
				}

				if(buffer[i+8] != 0)
				{
					printf("1\r\n");
					return 0;
				}
			}

			if(!((buffer[i] >= '0' && buffer[i] <= '9') || buffer[i] == '.' || buffer[i] == 0 ))
			{
				printf("2\r\n");
				return 0;
			}

		}

		if(pointCount > 1)
		{
			return 0;
		}
		else if( pointCount == 0)
		{
			if(buffer[3] != 0)
			{
				return 0;
			}
		}

		if(buffer[11] != 0)
		{
			return 0;
		}

		return 1;
	}
	else
	{
		return 0;
	}

}
/*********************************************************************************************************
** 函数名称: putchar
** 功能描述: 重定向系统的printf函数
** 输　入:	 无
** 输　出:   无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
#if 1
int putchar(int c){
    //if(c== '\n'){
    //  while(!UTX0IF);
    //  UTX0IF = 0;
    //  U0DBUF = '\r';
    //}
#if 0
    while(!UTX0IF);
    UTX0IF = 0;
    return (U0DBUF = c);
#endif
	U0DBUF = c;
	while(!UTX0IF);
    UTX0IF = 0;
    return (c);
}
#endif


/*********************************************************************************************************
** 函数名称: Timer4_Init
** 功能描述: 初始化用于系统的定时器(1ms 产生中断)
** 输　入:	 无
** 输　出:   无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void Timer4_Init(void)
{


   uint8 timer4Period = 30;
   TIMER34_INIT(4);
   timer4Period = SetTimer34Period(4, 1000);
   if(timer4Period != 0)
   	{
      TIMER34_ENABLE_OVERFLOW_INT(4,INT_ON);
	  T4CCTL0|=0x04;
      INT_ENABLE(INUM_T4, INT_ON);
      TIMER4_RUN(TRUE);
	 }

}


/*********************************************************************************************************
** 函数名称: UART_Init
** 功能描述: 初始化串口
** 输　入:	 无
** 输　出:   无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART_Init(void)
{
	P2DIR &= ~0xC0;//端口0的外设优先级，依次UART0,UART1，定时器1
  	P2DIR |= 0x00;//输入

	/*初始化串口0*/
	IO_PER_LOC_USART0_AT_PORT0_PIN2345();

	UART_SETUP(0, 115200, HIGH_STOP);
	//UART_SETUP(0, 230400, HIGH_STOP);

	UTX0IF = 0;
	URX0IF = 0;//清除串口接收中断标志
	URX0IE = 1;//接收中断使能
	U0CSR |=0x40;
}


/*********************************************************************************************************
** 函数名称: ChangeBaudrate
** 功能描述: 改变UART0,UART1的波特率到115200(权宜的简单操作)
** 输　入:	 无
** 输　出:   无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void ChangeBaudrate(void)
{
		U0GCR  = 11;
		U0BAUD = 216;

		U1GCR  = 11;
		U1BAUD = 216;
}


/*********************************************************************************************************
** 函数名称: UART0_SendByte
** 功能描述: UART0发送字节
** 输　入:	 data			发送字节
** 输　出: 无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART0_SendByte(uint8 data)
{
	U0CSR &= ~BIT1;
	U0DBUF = data;                  //发送字节数据
    while(!(U0CSR & BIT1));         //等待发送数据寄存器为空
    U0CSR &= ~BIT1;
}
/*********************************************************************************************************
** 函数名称: UART0_SendData
** 功能描述: UART0发送字符串
** 输　入:	 *pbuff			待发送字符串首地址
**			 len			字符串长度
** 输　出: 无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void UART0_SendData(uint8 *pbuff, uint16 len)
{
    uint16 i;
	//发送前清空标志，避免错误
	U0CSR &= ~BIT1;
	for(i = 0;i < len;i ++)
	{
	    U0DBUF = pbuff[i];                  //发送字节数据
	    while(!(U0CSR & BIT1));         //等待发送数据寄存器为空
	    U0CSR &= ~BIT1;
	}
}
/*********************************************************************************************************
** 函数名称: SetTimer34Period
** 功能描述: 设置T3或者T4的间隔时间
** 输　入: 	 timer  定时器
**           period 间隔时间(单位us)
** 输　出:   间隔时间
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
uint8 SetTimer34Period(uint8 timer, uint32 period){

		uint8 div = 0;

		if(CC2530_GET_TICKSPD() > 5) { // Checking that the period is not too short.
			if( (period < 2*(CC2530_GET_TICKSPD()-5)) && (period != 0) ){
			   return 0;
		    }
		}

		if(period == 0){  // If period is 0, max period length and max prescaler
				div = 7;  // division is used.
				period = 255;
		} else {
				period = ((period*32) >> CC2530_GET_TICKSPD());// Determining how many timer ticks the period consist of
				while(period > 255){			  // If the period is too long, the prescaler division is
						period = (period >> 1);   // increased.
						div++;
						if(div > 7){			  // If the period is too long when using max prescaler division,
								return 0;		  // 0 is returned.
						}
				}
		}
		if(timer == 4){
				// Timer 4 selected
				T4CTL |= (div << 5);			  // Setting prescaler value
				//T4CTL |= (5 << 5);
				T4CC0 = (uint8) period;			  // Setting timer value.
				//T4CC0 = (uint8) 200;
				//return 250;
		} else if(timer == 3){
				// Timer 3 selected
				T3CTL |= (div << 5);			  // Setting prescaler value
				T3CC0 = (uint8) period;			  // Setting timer value.
		} else {return 0;}

		return period;


}


/*********************************************************************************************************
** 函数名称: BoardInit
** 功能描述: 板级外设初始化
** 输　入: 无
** 输　出: 无
** 全局变量: 无
** 调用模块:
**
** 作　者: 袁舰
** 日　期: 2015年7月17日
**-------------------------------------------------------------------------------------------------------
** 修改人:
** 日　期:
**------------------------------------------------------------------------------------------------------
********************************************************************************************************/
void BoardInit(void)
{
	INTERRUPT_OFF();

	//时钟初始化
    clockSetMainSrc(CLOCK_SRC_XOSC);

	//T4初始化
	Timer4_Init();

	//USART初始化
	UART_Init();

	//DMAInit();

#ifdef  DATA_HUB
	//LedTestInit();
#else
	//MESSAGE0();
#endif
	LedInit();


	// Interrupt Priority
	INIT_INTERRUPT_PRIORITY( );

	INTERRUPT_ON();

}


